这个算法的核心就是在递归的基础上记录已经算过的状态，如果下次运算过相同的状态，直接返回已经算过的状态，避免重复运算。

优点：掌握了暴力搜索，比如回溯和递归的写法之后，入门会非常的简单，时间复杂度与常规的（自底向上）动态规划是一致的。

缺点：由于依然是使用递归，所以当数据规模大的时候会有比较大的栈消耗

总结：如果笔试的时候想不出自底向上的动态规划，那么直接使用记忆搜索就可以了

因为暴力搜索二叉树的复杂度是 2 的 n 次方，因此只要 n 的规模大一点点，就肯定会超时。
但可以发现递归的时候有很多重复的运算

```java
int n;

int[] dp = new int[n+1];
//dp 初始值不一定是-1，只要是不可能出现的值就可以了
Arrays.fill(dp,-1);
int dfs(int cur){
    if(cur >= n) return cur == n? 1 : 0;
    //在暴力搜索的基础上改造成 dp 
    //如果不等于-1，说明已经遍历过了 
    if(dp[cur]!=-1) return dp[cur];
    return dp[cur] = dfs[cur+1] + dfs[cur+2];
}
```
如果是 c++ 和 java，就用 dp 就行了，如果是js 或者 python，可以用 map 来做，当然用数组也可以

记忆化搜索是必须要带着``返回值``的
1 递归调用
2 判断该状态是否被计算过
3 递归调用并且计算对应的返回值
